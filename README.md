
一种快速生成数独的方法。依赖eigen 3，需要C++11支持。

# 基础知识
约定4种解题技巧，对应4种难度。
1. 唯一解：候选x在某一行/列/宫只出现一次，或某格只有一个候选，即可确定。
2. 宫线消去：如图

 ![line](img/lineRemove.png "line")

3. 闭环消去：在同一行/列/宫的未知格中，若某n格中只可能是n个数字，别的格子中可以排除这些数字；若某n个数字只出现在n个格子中，这些格子中可以排除别的数字；若候选x在某n列（行）中只出现在n行（列）中，这些行（列）中其它列（行）可以排除x。
4. 假设消去：如图

 ![assume](img/assumeRemove.png "assume")

   PS：假设消去完全兼容宫线消去，兼容闭环消去的第3种情况。

会这4种技巧就算是入门了，更高级的技巧暂未实现。用这4种技巧无法解题，却有唯一解的，定为难度5。

# 生成答案
首先在第1、5、9宫中各自填入集合[1，9]的一种随机排列，如：

        145000000
        927000000
        836000000
        000732000
        000865000
        000491000
        000000786
        000000351
        000000924

然后用深搜求解。

# 生成原题
1. 在答案中随机取30个数，其余删去；
2. 用唯一法求解，直至无解；
3. 在未填的格子中，取候选数量最多的，填入正确答案；
4. 重复2~3，直到填满81个数；
5. 1、3中的数字加起来即是原始题目。

# 精简
对原题中每个点定个属性，如果删除这个数，不能保证唯一解，则该点为锚点。每次删除一个数，剩下的数字属性会发生变化。锚点永远是锚点，非锚点能变成锚点。

流程：

1. 遍历题目中每个点；
2. 如果是非锚点，则删除。

# 控制难度
鉴定难度略。目前无法精准控制难度，只能用拉斯维加斯算法穷举。可以把得到正确结果之前的题目用数据库保存，当要求某个难度的题目时先查表，没有再穷举，这样也能提高速度。生成难度1和5的题目的概率最高，难度3的概率最低，但也大于5%

经测试，在i7-12700H 2.30 GHz的机器上，单线程跑程序，生成一个题目平均花费时间小于0.6ms。
