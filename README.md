
一种快速生成数独的方法。依赖eigen 3.4，需要C++11支持。

# 基础知识
约定4种解题技巧，对应4种难度。
1. 唯一解：候选x在某一行/列/宫只出现一次，或某格只有一个候选，即可确定。
2. 宫线消去：如图

 ![line](img/lineRemove.png "line")

3. 闭环消去：在同一行/列/宫的未知格中，若某n格中只可能是n个数字，别的格子中可以排除这些数字；若某n个数字只出现在n个格子中，这些格子中可以排除别的数字；若候选x在某n列（行）中只出现在n行（列）中，这些行（列）中其它列（行）可以排除x。
4. 假设消去：如图

 ![assume](img/assumeRemove.png "assume")

   PS：假设消去完全兼容宫线消去，兼容闭环消去的第3种情况。

会这4种技巧就算是入门了，更高级的技巧暂未实现。

# 生成答案
首先在第1、5、9宫中各自填入集合[1，9]的一种随机排列，如：

        145000000
        927000000
        836000000
        000732000
        000865000
        000491000
        000000786
        000000351
        000000924

然后用深搜求解。

# 生成原题
1. 在答案中随机取30个数，其余删去；
2. 用唯一法求解，直至无解；
3. 在未填的格子中，取候选数量最多的，填入正确答案；
4. 重复2~3，直到填满81个数；
5. 1、3中的数字加起来即是原始题目。

# 增加难度
对原题中每个点定个难度，即：如果删除这个数，能不能通过剩下的数字，推理出它。由此分为三种：易点（难度1）、难点（难度>1）、锚点（难度-1，删除它则无法保证唯一解，或者需要使用更高级的解法才能推理出它）。每次删除一个数，剩下的数字难度会发生变化。锚点永远是锚点，易点能变成难点或锚点，难点能变成锚点。

流程：

1. 更新题目中每个点的难度；
2. 选择难度最高的点删除；
3. 重复1~2，直至剩下的全是锚点。

流程中删除点的最高难度，即是最终题目的难度，原题难度一定为1。这个算法可以控制题目难度的上限，却无法控制下限，待完善。
